# 절두체 컬링(Frustum Culling)

그리는 것이 시간이 많이 걸린다? -> 만약에 미리 공간에 들어가 있는지 판단 할 수 있다면

--> 절두체 컬링 (그리기 이전에 판단)

전체적으로 프레임 레이트를 높일 수 있다.

근평면 ~~~> 원평면
Plane 상하좌우

어떤점이 절두체 안에 있다 -> 보인다.

x, y, z가 평면에 방정식으로 전부 음수가 나오면 절두체 안에 들어옴
-> 하나라도 양수가 나오면 안들어 온것.

* 원근투영 변환
* 카메라 좌표계

원근 투영 변환 행렬이 있고 상하좌우 평면을 알고 거리를 알면 컬링에 대한 계산을 할 수가 있다. (평면의 방정식을 도출 해낼 수 있다)

v(카메라 좌표) * P(원근 투영 변환 행렬) = 
(x, y, z, 1) * P = v' = (x', y', z', 1)
 = (v * P1, v * P2, v * P3, v * P4) -> 각 행렬끼리의 내적이다!
 = (x * xScale, y * yScale, (z - zn) * zf/(zf - zn), z)

평면 관련 식을 보니까... -> 평면의 방정식 모양이다!

*정점이 절두체 6개의 평면의 앞에 위치 -> 절두체 안에 들어있는 정점

m -> 원근 투영 변환

a = (m14 + m11)
b = (m24 + m21)
c = (m34 + m31)
d = (m44 + m41)

원근 투영 변환 행렬로 부터 카메ㄴ라 좌표계의 6개의 평면의 방정식을 구할 수 있음. 어떤 점이 안에 있는지 아닌지는 평면의 방정식을 대입해보면 된다!

# DirectX 충돌 검사
절두체 (Bounding Frustum) 
BoundingFrustum함수를 이용하여 절두체를 만들고()
충돌검사 함수를 쓰면 된다!

-> ContainedBy, Contains, ... , Intersects, ...
6개의 평면 도출 함수 -> 카메라 좌표계를 기준으로 변환된다.

World 좌표계 -> Camera 좌표계

Transform -> 모든 Bounding Structure에 모두 적용되는 함수이다.
월드 좌표든 뭐든 검사를 할때 원하는 행렬을 가지고 변환하면 된다.

*카메라 좌표계에서의 모든 평면은 무조건 카메라의 원점을 지난다.

그냥 XMath함수 써서 구하자! -> 편하니까..

모든 오브젝트 들은 바운딩 박스가 필요하다.. (ABB, OBB 충돌)
충돌 처리 검사 (AABB, OOB?) 상황에 따라서 검사 함수 사용

xmInvView -> 그냥 ViewMatrix의 역행렬

Intersects. True일때 -> 절두체 안에
            False일때 -> 절두체 밖에
