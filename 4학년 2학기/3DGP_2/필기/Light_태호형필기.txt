[Chapter06 ? Light]
<Light>
가상적인 게임세상에서 빛을 내는 물체가 있다면 그 빛들은 직진해서 물체의 표면에 반사가되어 표면의 색상이 정해진다.
빛의 반사를 계산하고 물체의 표면의 색상이 결정되는 것을 조명계산,조명처리라고 한다.
조명 계산을 하는 문제는 3D세상을 처리하는데에 있어서 중요하기도하고 어려운 문제이다.
반사로 인해 물체의 색이 정해지는 기본적인 방법은
Ambient, Diffuse, Specular, Emissive한 성질이 있을 수가 있다.

모든 빛들을 normalize하면 크기가 1인 빛으로 표현 할 수 있다.
빛이 가장 강할때가 1, 빛이 없을 때를 0이라고 한다면 빛을 0~1사이의 값으로 표현 해 낼 수 있다.

<Material>
물체가 빛의 반사의 성질을 재질이라한다.

Light와 Material을 컴포넌트곱하기를 하면 반사되는 색상이 결정되는 것이다.
물체가 어떤 색상을 반사를 잘한다고해서 그색상이 아니다.
빛의 색상이 어떠냐에 따라서도 물체의 색상이 달라지기도 한다.
즉, 빛의 색상과 빛을 반사하는 재질의 성질들이 수학적으로 곱해진 것이 우리눈에 보이는 색상이다.

재질은 색상이 아니라 빛의 반사의 성질을 색상으로 표현한 것 뿐이다.

<Emissive Illumination>
물체의 표면에서 발광이 일어나고 있는 물체.

조명의 반사는 크게 두가지가 있다.
1. 직접반사
a 어떤 빛이 물체에 직접 닿아서 반사하는 것이다.
2. 간접반사.
a 한번 물체에 반사된 빛이 또 다른 물체에 반사를 하고 또 반사를 하는 그런 반사이다.


간접반사를 수학적으로 표현하려면 많은 연산이 필요하다.

그렇기 때문에 Ambient는 어떤 공간에 균일하게 퍼져있다고 가정하는 것이다.






< 직접조명 >
어떤 물체에 직접 빛이 반사된다고하면 그 물체는 주변의 물체보다 더 밝아야한다.
1. Diffuse Reflection
a 직접 조명을 계산한다.
질감이라는 것이 결국 빛의 반사의 정도를 계산한다.
빛이 표면에서 여기저기 반사가 일어나는 것을 Diffuse Reflection이라고 한다.
(난반사광)
매끄러운 표면은 난반사가 일어나지 않는다.


2. Specular Reflection
a 빛이 들어온 입사각에 대한 반사각으로 특정한 방향으로 반사가 많이 되는 것을 Specular라 한다.
반사의  정도가 가장 밝은 부분을 하이라이트라고 한다.

아무리 표면이 매끄러워도 현미경으로 들여다보면 굴곡이 있다. 그렇기 때문에 하이라이트로 반사가 강한것이지 그 주변으로도 반사가 되어 빛이 퍼지게 된다.

Ambient Light
Ambient는 공기중에 반사되고 반사된 빛들이 있는 것이니 Ambient Light이라고 한다.

Diffuse, Specular Reflection의 경우 어떤 한 점에서 반사되는 빛은 빛의 밝기와 cos세타를 곱한 것만큼 밝기가 줄어든다.

어떤 빛들이 어떤 한점에 굉장히 많이 비춰서 이미 최고의 빛이 정해졌다면 아무리 더 많은 빛으로 비춘다 하더라도 의미가 없다.
이미 어떤 감각기간이 최대의 감각을 느끼고 있으면 그것을 넘어서면 의미가 없어진다.
(베버의법칙)














물체의 표면에서 빛을 반사하는데
diffuse - 난반사가 일어나서 모든 방향에서 동일한 방향으로 반사가 일어나는 것
specular - 표면이 매끄러워서 특정한 부분으로만 많이 반사되는 것

물체의 표면은 대부분 입체를 생각한다.
빛이 들어가면 물체에 따라서 전부다 반사만 일어나는 것이 아니라 물리적으로 어떤 빛의 일부는 물체의 내부로 들어가서(물체가 빛이 흡수하는 형태) 들어가서 굴절되어서 나가는 경우도 있고 나가지 않는 경우도 있다.(물체가 투명한경우 굴절등으로 나가게됨)
프레넬반사?
빛이 반사가 되는데 핵심은 물체의 표면이 거칠면 diffuse한 반사가 많이 일어나게 될 것.
표면에서 여러 방향으로 난반사가 되어서 빛을 비추었을 때 어느 특정한 방향으로 반사되는지 모르니
물체의 표면이 모든 양으로 반사가 된다고 가정해서 한다.(샘플때는)
카메라가 어느 위치에서 보든지 그 물체의 색상이 동일하다고 가정.

specular반사는 난반사가 일어나지 않고 입사각과 반사각이 같은 각도로 일어난다고 가정하면 특정 방향으로 가는 반사만하고 이렇게 빛의 반사가 많이 일어나는 것을 하이라이트 라고 한다.
이러면 다른 부분보다 빛을 더 많이 반사하니 반짝거리게 보일 것이다.

하이라이트는 카메라가 바라보는 위치에 따라서 하이라이트가 다르다.

물체의 표면이 거칠면 ? diffuse
물체의 표면이 매끄러우면 ? specular

물체는 한가지 반사만 일어나는 것이 아니라 여러가지 반사가 같이 일어난다.

diffuse,specular 모두 물체의 표면에서 반사가 되면 반사되는 빛의 세기

빛이 표면에 비추면 일부는 에너지를 물체가 흡수하고 일부는 반사가 되어 빛이 약해진다.
(원래의 물리적인 에너지 보존법칙으로는)

줄어드는 양은 법선벡터가 n이라고 할 때 입사각과 법선벡터의 cos세타와 비례하도록 줄어들도록 계산한다.
이렇게 하는 방식을 램버트 조명 모델, 램버트 조명방식이라고 한다.

매우 정밀하게 빛의 반사를 계산하려면 많은 데이터와 연산과 처리가 필요하므로 일반적인 수준에서 간단하게 빛에 대해서 표현하는 방식으로 램버트방식이 적절하다.

어떤 물체의 표면에서 spec과 diffse 반사가 일어나는데 실제로 반사가 일어나도 spec은 적게 일어나고 diffuse는 대부분 일어나므로 일반적인 물체는 diffuse반사가 많이 일어나고 specular는 금속 같은 물체에서는 빛의 반사가 더 많이 일어난다?


카메라가 정점을 바라보는 시선벡터와 n과의 반사벡터 r을 구하고
이 r이 조명과 cos세타가 0이면 밝게 보일것이고 세타가 커질수록 거의 안보일 것이다.

R과 L을 내적해서 단위벡터로 만들면 내적의 양만큼 반사의 양이 정해지게 될 것이다.
반사가 얼마만큼 일어날 것인지에 대해서 p승의 p값에 대해서 결정해야 한다.
p가 10보다 20이 더 급격하게 0이 될 것이다.
이것은 표면의 매끄러운 정도를 표현하기 smoothness, power라고 표현.

spec이 넓게 일어나면 딱딱하고(p의 크기가 작을때) 매끄럽지 않고 좁게 일어나면 매끄럽고 좁게 일어난다(p의 크기가 클때)).

즉, p는 물체 표면의 매끄럽고 딱딱한 정도를 표현하는 수치.

<간접반사, ambient>
일반적으로 

Global Illumination.
Physics Based Rendering
위 두 조명방식으로 표현하려면 물리적이고 수학적인 지식들이 필요함.


물체의 표면에 빛이 닿았을 때 어떻게 보일 것인가?
빛의 색상 L, 물체의 색상 M
일반적으로는 L과 M의 요소별곱연산으로 표현.
그리고 이 specular와 반사양을 정하기 위한 N(정점의 N, 폴리곤의 N 등 여러가지 방식)

IAaVSaRSaOM
위 정보들을 활용하여 조명처리를 할 수 있다.

조명처리는 일반적으로는 Pixel Shader에서 연산하는 것이 맞다.

여기서 PixelShader에서 매 조명 처리를 한다고 하자.
정점쉐이더에서는 3번만 호출하게 되겠지만
픽셀쉐이더에서는 삼각형을 렌더링 하기 위해서 거리가 가까우면 픽셀 수가 많아지고, 거리가 멀어지면 픽셀수는 적어진다. 결과적으로 라이팅을 위한 연산처리하느라 매우 많은 시간을 소비하게 된다.

프레임레이트를 생각하면 항상 픽셀쉐이더에서만 해야한다면 유연성이 떨어지게 된다.
예를 들어서 사양에 따라서 혹은 사용자 측에서 원하는 방식으로 쉐이딩 처리방식으로 정하도록 제공을 하도록 한다면 퐁쉐이딩과 고로쉐이딩, 플랫쉐이딩 등 여러 방식들을 제공하여서 원하는 방식으로 하게끔하면 프레임레이트 관리를 유저측에서 정해서 사용이 가능하다.
(즉 이런식으로 제공을 해야 프레임레이트 방어를 하기 위한 다양성을 제공이 가능해진다.)
그러므로 VertexShader에서 정점에 대해서만 한번씩 조명을 계산을 해주면 훨씬 조명 처리에 대한 시간이 적게 들기 때문에 프레임레이트 향상이 된다.
(하지만 이렇게 되면 픽셀쉐이더에서 처리한 것보다 더 정밀한 조명처리가 되지 않는다.)

예를 들어서 커다란 사각형 한가운데를 스포트라이트 조명이 비춘다고 가정을 하면
조명 연산처리를 하여도 검은색으로 나오게 될 것이다.
이런 방식을 활용하기 위해서는 모델의 정점을 더 많이 사용하도록하여 버텍스쉐이더에서 처리를 하더라도 조명연산이 가능하게 끔 모델이 되어야한다.
(이 경우에는 모델을 하이폴로 바꿔야 할지, 방식을 찾아야할 듯, 혹은 면에 대한 법선에 대해서 계산?)

유니티의 같은 경우에는 베버의 법칙을 활용하여 조명을 굉장히 많이 만들어도 조명의 밝기를 소팅해서 그중에 가장 밝은 조명에 대해서는 4개로 픽셀쉐이더로 계산을 하고 나머지 조명에 대해서는 정점조명을 하여서
인터폴레이션해서 쓰거나 혹은 안쓴다.
이런 방식으로 조명에 대한 연산처리 방식을 효율적으로 한다.

베버의법칙 e 어떤 감각에 대해서 자극이 강하게 들어오면 그에 비슷한 자극이 와야지 느끼게 되는 것

일반적으로 물체의 색상에 대한 것은 Diffuse 반사에 대한 결과이다.

조명연산을 하려고 하면 모든 정점들은 법선벡터 정보가 필요하다.
그리고 모든 물체들은 추가적으로 물체에 대한 Diffuse, Ambient, specular emissive, specpower 값이 필요하다.

<간접조명, Ambient>
1.Material의 Ambient
2. 글로벌 조명의 ambient와 (정점에 영향을 주는 N개의 조명에 Ambient를 요소별 합연산.)을 요소별 합연산.
위 두가지를 요소별 곱연산 하면 된다.

<직접조명, Diffuse>
1.Material의 Diffuse
2. 조명의 diffuse와 Lambert요소를 요소별 곱연산에 모든조명의 합연산
위 두 가지 요소를 곱연산 하면 Diffuse

1.Material의 Specular
2. 조명의 Specular와 Specular(지수승한 값)
간편하게 카메라의 위치로부터 구하지않고 고정된 벡터 (0,0,1)과 계산해서(근사해서) 정해도됨.
위 두가지 요소를 곱연산하면 Specular

H벡터는 카메라와 정점과 벡터와 조명과 정점과의 벡터를 합한 대각선의 벡터값.



<정점의 법선벡터>
정점은 포함된 각 면에 대한 방향벡터에 대한 정보가 필요하다.
포함된 각 면에 대한 방향벡터에 대해서 모두 더한 벡터를 normalize한 벡터가 정점의 방향벡터가 될 것이다.

정점이 인덱스정보로 표현이 된다면 정점이 사용한 모든 폴리곤에 대한 법선의 평균을 내면 된다.

정점이 법선벡터를 가지고 있으면 정점의 위치를 변환을 한다면 정점의 법선벡터도 변환을 해야한다.
위치가 변환이 되었으면 그에 따른 법선벡터도 그에 맞게 변환이 일어나야 한다.
폴리곤의 접선과 법선은 항상 수직이어야한다.
Scale로 (2,1)한다면 Scale의 역행렬의 Transpose한 행렬을 곱해야한다.

결국 법선벡터를 변환을 하려고 하려면 역행렬의 전치행렬로 변환을 해야한다.
이렇게 해야 정확한 결과값을 얻어 낼 수 있다.
이 경우는 스케일변환이 일어났을때만 일어나게 된다.

스케일 변환을 하지 않는다면 변환을 해도된다.
하지만 스케일 변환을 하지 않는다고해서 그냥 변환만 하는 것이 아니라 법선을 normalize하는 과정은 해줘야한다.

특히 스큐스케일링?(한쪽으로만 스케일링하는 것)을 하는 것은 특히 더욱 금지이다.
스케일링을 하면 꼭 쉐이더에서 변환을 할 때 위의 과정을 해줘야한다.(이왕이면 스케일에맞는 모델링자체를 추가적으로)

AreaLight??

<Point Light>
어느 한 위치로부터 모든 방향으로 빛을 내는(즉, 구의 형태로 나타내는) Light.
어느 위치로부터 모든 방향에 대해서 연산을 하지만 중심으로부터 멀어질수록 빛의 세기(Attenuation)가 달라진다.

필요한 정보는 위치, 범위(반지름), 감쇠(Attenuation)이 필요하다.