저번 시간
- 왜 멀티쓰레드 프로그래밍을 해야하는가?
- 쓰레드는? 프로세스와는 무엇이 다른가? (OS)
- 메모리 구조. 쓰레드 구조 -> 운영체제 상관없이 똑같다.

어떻게 성능을 높이냐? -> 작업을 나눠서.. 병렬

# 멀티 쓰레드 프로그래밍에서 중요한 사항
-올바른 결과가 도출되어야 한다.
=> 당연한 코드인데 엉뚱한 결과가 나올 수 있다.
-멀티 쓰레드로 인한 성능향상이 커야 한다.
=> 작업을 분할 해야한다.

메모리 자체의 산술연산은 존재하지 않는다. -> 읽고 쓰기 밖에 하지 못한다.
=> CPU에서 처리한다.

쓰레드1, 2가 동시에 실행되면서 순서가 꼬이게 되는 문제
예를들어 쓰레드1에서 200가 들어가 202가 나오는데, 쓰레드2에서도 200이 들어가 202가 나옴.. => 순서문제..

이런 문제는 디버깅을 힘들게 한다 -> 결국 운영체제를 잘 아는게 최고다!

*원인
-공유 메모리를 여러 쓰레드에서 읽고 쓴다.
-읽고 쓰는 순서에 따라 실행결과가 달라진다.(예상 못한 결과)
-이것을 'Data Race'라고 한다.
	
*Data Race <경쟁상태>
=> 복수개의 쓰레드가 하나의 메모리에 동시 접근
=> 적어도 한 개는 Write

*Data Race를 제대로 이해하고 있는가?
=> 멀티쓰레드가 어려운 주범..
해결법?
-> 복수의 쓰레드를 쓰지 말아라 
-> 하나의 메모리에 동시 접근 => 쓰레드끼리 데이터를 주고 받지 말라..
==> 뭐야 멑리쓰레드 쓰지 말라는거야?

-앞의 프로그램을 싱글코어에서 동작시키면 결과는?
=> 하지만 틀린값이 나올 수도 있음. (1/20 확률로)

-앞의 프로그램의 "sum+=2"를 "_asm add sum,22"로 바꾸면?
=> 그래도 똑같음.. 차이 없음

-"_asm add sum,2"로 바꾼 후 싱글코어에서 동작시키면?
=> 제대로된 결과가 나온다. 계속해서 정확한 값이 나온다!
왜?? => Context Switch

*명령어 실행중에는 절대도 interrupt가 걸리지 않음.

# 해결방법 (Data Race)
-Data Race를 없애면 된다. ㅡㅡ;

*어떻게?
-Lock과 Unlock을 사용한다. (OS시간에 배움)
=> 동시에 접근하지 말아라.. (쓰레드가)
동시에는 하나의 쓰레드만 접근할 수 있도록 한다.

#Lock과 Unlock

mutex -> multi exclusive 상호 배제

*주의점..
-Mutex객체는 전역
-같은 객체 사이에서만 Lock/Unlock이 동작*
-서로 동시에 실행돼도 괜찮은 critical section이 있다면 다른 mutex객체로 보호하는 것이 성능에 좋음 => 같은 mutex객체로 보호하면 동시에 실행이 안됨.

*critical section(임계 영역) : 무엇인가? 운영체제 시간에 배움.

* Lock Unlock을 쓰면 => 정확한 값이 나온다. 하지만... 큰문제가 있다.
=> 더럽게 느려졌다...

# 얼마나 느린가??
약 70~100배 정도 느리다...
왜 느린가??? 

그러면 쓰레드를 더욱 늘려보자
=> 읭? => Lock이 아닌 상태에서는 존나게 느리네? 
Lock을 하고 돌리면? => 그래도 느리네?? 시발? 오히려 점점 느려지네..
CPU를 풀로 사용하고 있는데??

==> 왜?
*잠깐!!!
*성능 측정????
*디버그 모드에서의 성능 측정은 무의미
-멀티쓰레드 목적은 오로지 성능
*이제부터 릴리즈 모드에서 측정을 하자.

비주얼 스튜디오의 농간이다!!
=> 포문을 돌리는걸 아무것도 하지 않는다.. => 뭐하는 프로그램인지 알고 자체 최적화를 해버린다...

# 위에대한 해결책 => 최적화를 하지 마라..
해결책 : VOLATILE

Register => 최적화를 해라 => 삭제 해버려서 없어짐..
Volatile => 최적화를 하지 마라!

#Mutex의 lock()이라는 물건은...
=> 일을 나눠서 따로 하도록 해주는 애 => 멀티 쓰레드 의미가 없다..
-한번에 하나의 쓰레드만 실행
-Lock을 얻지 못하면 Queue에 순서를 저장하고 스핀
-심각한 성능 저하

=>lock, unlock의 오버헤드도 엄청나게 크다.

# 해결 방법
- Lock을 쓰지 않으면 된다.
- Sum+=2를 하는 동안 다른 thread가 실행되지 못하도록 하면 된다.
(lock없이)

How??
CPU단에서 컨트롤 해주자.
-X86 어셈블리 언어의 'lock' prefix를 사용하여 "sum+=2"를 atomic하게 실행 시킨다.

아 근데 정확한 값이 나왔는데 왜 또 지연시간이 점점 생겼는가; ㅠ
다음시간에