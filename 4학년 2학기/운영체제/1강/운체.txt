#운영체제 Chapter 01

운영체제가 하는일 
==> 컴퓨터를 쉽게 사용할 수 있게 해주기

-> 프로그램을 쉽게 실행
-> 프로그램간의 메모리 공동 사용
-> 장치와 상호작용 기능 제공

# 가상화(Virtualization)
* 실제(Physical)자원을 사용하기 쉽도록 가공해서 제공하는것.
-실제 자원 : CPU, 메모리, 디스크
-(운영체제를 가상머신이라고 부르기도 함? : 그런 사람 별로 없음)

* CPU, 디스크를 날 것으로 컨트롤 하는 것은 너무 어려움, 운영체제가 쉽게 컨트롤 할 수 있도록...

# 시스템 콜(System Call)
* CPU, 디스크를 날 것으로 컨트롤 하는것은 너무 어려움, 쉽게 사용 할 수 있도록 제공하는 간단한 표준 API

# 자원 관리자
* 여러 개의 프로그램을 동시에 실행할 때 자원의 효율적인 배분과 공유, 재사용을 담당


가상화, 자원 관리, 시스템콜

# CPU 가상화
*작업 관리자를 실행해보자.
-많은 프로그램이 실행되고 있다.
-프로그램을 작성하면서 다른 프로그램에게 CPU를 양보 한 적이 있는가?

*마치 컴퓨터에 수십 개의 CPU가 존재한다는 가상화가 있다.
-CPU를 무한한 개수의 CPU로 증식
-이를 통해 많은 프로그램을 즉시 실행 시킴

# 메모리 가상화
* 실제 메모리는 Byte의 배열
-배열 : C언어의 그것, array

*프로그램의 모든 자료 구조는 메모리에 있다. 
(Disk에 있는 데이터도 일단 메모리에 읽어 놔야 읽을 수 있다.)
-메모리 읽기 (Read, Load) : 주소를 주고 데이터를 얻기
-메모리 쓰기 (Write, Store) : 주소와 데이터를 주고 쓰게 하기.

*'조작'을 믿으세요
-같은 주소에 +1을 하는 프로그램이 여러 개 인데 왜? 1씩 증가하는가?
* 모든 실행중인 프로그램은 각자 고유의 메모리를 가지고 있다..
-같은 주소를 읽고 쓰지만 프로그램이 다르면 다른 메모리이다.
-모든 프로그램은 같은 주소에서 실행된다.
(서로 주소가 겹친다)

==> 보안 때문에 메모리를 가상화 시킨다. (직접 메모리에 접근하지 못하게)

*전문용어를 사용하면
*각 프로세스는 각자의 가상 주소 공간을 갖는다.
-운영체제가 가상 주소를 실제 주소로 매핑한다.

(Mapping)
-실행중인 프로그램이 메모리를 건드릴 때 다른 프로세스의 메모리에는 영향이 없다.
-실제(physical)메모리는 운영체제의 관리를 받는 공유 자원(shared resource)이다.

# 병행성
* 운영체제는 여러가지 일을 동시에 수행하는 곡예를 하고 있다.
-프로세스를 하나 실행하고, 다음 프로세스를 실행하고, 또 다음 프로세스를 실행하고...

*현대의 멀티쓰레드 프로그램은 병행성 문제를 추가로 가지고 있다.

*프로그램
-두개의 스레드를 만든다.
-스레드 : 같은 주소공간에서 동시에 실행되는 함수
-각 스레드는 worker()를 실행한다.
-worker() : 카운터를 증가시킨다.

# 병행성 문제
*왜?
 - 공유 counter증가 -> 3개의 명령 필요
-> 메모리에서 counter값을 읽어서 레지스터로
-> 레지스터 증가
-> 레지스터의 값을 다시 counter로

-각각의 명령어들은 원자적(atomic)으로 수행되지 않는다. 
--> 병행성 문제의 발생

* 앞으로 이러한 문제들을 어떻게 해결할 지 배우도록 한다..

# 영속성
* DRAM과 같은 메모리는 휘발성(volatile)이다.

* 영구적으로 데이터를 저장할 수 있는 하드웨어와 소프트웨어가 필요하다.
- 하드웨어 : 하드디스크, ssd -> I/O장치
- 소프트웨어 : 사용자가 생성한 파일들을 관리하는 파일시스템

*-> open(), write(), close()는 시스템호출로 운영체제에 있는 파일 시스템에 요청을 전달한다.

* 디스크에 쓰기 위한 OS의 동작은?
-새 데이터가 들어갈 위치를 디스크에서 찾는다.
-저장장치에 I/O요청을 한다.

* 파일 시스템은 쓰는 도중 컴퓨터 크래시를 처리한다.
-저널링, 쓰기 - 시 복사
-쓰기 순서 조정

# 설계 목표
* 가상화 구현
-시스템을 쉽고 편리하게 사용할 수 있도록

*높은 성능 제공
-운영체제 오버헤드 최소화
-지나친 가상화 배제

*응용 프로그램 간의 보호
-고립(isolation) : 프로그램의 오동작이 다른 응용 프로그램이나 OS에 피해를 입지 않도록 하는 것

*높은 실뢰성
-OS는 죽지 않아야 한다..

*추가적인 목표
-에너지-효율성(energy-efficiency)
-보안(security)
-이동성(mobility)





