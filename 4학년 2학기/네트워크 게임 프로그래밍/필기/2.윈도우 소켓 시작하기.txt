=> 윈속 함수의 오류 처리 방법
디버깅, 소켓 error 예외처리

=> 윈속 초기화와 종료 방법
=> 소켓 생성과 닫는 방법


# 네트워크는...

-host     -   host 통신 이라기보다는...
 프로그램   -   프로그램 통신.

-프로그램에서 보낸 데이터 -> 목적지 프로그램 == 네트워크

-소켓은 전화망의 machanism 그대로 사용
=> 거의 평생 쓸 수 있음.

*네트워크 포트 -> 항구의 포트
*well-known port, 시스템 포트 => 이미 표준화된 포트
==> 이 포트는 사용하지 마라... (1~1024)

* 송신 측(Client)
소켓 생성 >> 포트 부여 >> 상대편 IP/Port 주소로 연결 >> 통신 >> 종료

* 수신 측(Server)
소켓 생성 >> 포트 부여 >> 상대편 연결 기다리기(Listen)
>> 통신 >> 종료

==> 각 역할에 맞는 소켓 API를 사용하면 된다.
    (Common API)

# 윈속 함수 오류 처리
# 오류 처리 유형

- 오류 발생시 오류를 체크하여 구체적인 오류 내용을 알려주는 것이 중요.
=> 오류와 예외처리는 다름

1. 오류를 처리할 필요가 없는 경우
-> 리턴값이 없거나 호출 시 항상 성공하는 일부 소켓함수

2. 리턴 값만으로 오류를 처리하는 경우
-> WSAStartup() 함수
-> 사용자가 직접 처리 못함

3. 리턴 값으로 오류 발생을 확인, 구체적인 내용은 오류 코드로 확인
-> 사용자가 직접 처리가 가능함
-> Most한 케이스임
-> WSAGetLastError() 함수를 사용하여 오류 코드를 얻을 수 있음

예]
if(소켓함수(...) == fail){
int errcode = WSAGetLastError();
printf(errcode에 해당하는 오류 메시지);
}

-> WSAGetLastError()를 문자열 형태로 출력하면 의미 해석이 더 쉬워짐.
FormatMessage() -> 오류 코드에 대응하는 오류 메시지를 		얻을 수 있음

# FotmatMessage()
dwFlags -> 옵션
dwMessageId -> 오류코드
dwLanguageId -> 기본언어
IpBuffer -> 오류 메시지 시작 주소

# err_quit() 함수 정의
=> FormatMessage()함수를 사용한 오류 처리 함수 예

# err_display() 함수 정의
-MessageBox() 대신 printf() 함수를 사용

# 윈속 응용 프로그램의 공통 구조

윈속 초기화 -> 소켓 생성 -> 네트워크 통신 -> 소켓 닫기 -> 윈속 종료

# 윈속 초기화
WSA(WinSockAPI)

모든 윈속 프로그램은 소켓 함수를 호출하기 전에 반드시
WSAStartup() 함수를 호출해야 한다. 

프로그램에서 사용할 윈속 버전을 요청함으로써 윈속 라이브러리인 WC2_32.DLL을 초기화하는 역할 수행

# 윈속 종료
프로그램을 종료할 때는 윈속 종료 함수인 WSACleanup()을 호출해야 한다.

윈속 사용을 중지함을 운영체제에 알리고, 관련 리소스를 반환하는 역할을 수행

* 자료구조와 운영체제 꼭!!
(컴구보다는)

# 소켓 생성
예) TCP 혹은 UDP 사용 여부를 결정하고 서로 약속함

윈도우는 소켓을 파일로 간주하지 않는다.

=> 사용자가 요청한 프로토콜을 사용해 통신할 수 있도록 내부적으로 리소스를 할당하고, 이에 접근할 수 있는 일종의 핸들 값(SOCKET 타입, 32비트 정수)인 소켓 디스크립터(socket descriptor)를 리턴

# 주소 체계

# 소켓 타입
자주 사용하는 타입 -> SOCK_STREAM(연결형 TCP), SOCK_DGRAM(비연결형 UDP)

# 프로토콜
IPPROTO_TCP, IPPROTO_UDP
프로토콜을 -으로 지정하면 운영체제가 알아서 소켓 형식에 맞는 디폴트 프로토콜을 선택해줌

# 소켓 닫기
소켓을 닫고 관련 리소스를 반환


