#멀티 스레드 프로그래밍은 언제 해야될까?
싱글 코어로는 동접이 안나오기 때문에...

1. 오래 걸리는 일 하나와 빨리 끝나는 일 여럿을 같이 해야할때 --> X
예) 로딩중에 게임을 한다던가
2. 어떤 긴 리치를 진행하는 도안 다른 짧은 일을 처리해야 할 때 --> X
예) 플레이어 정보를 읽거나 쓰려고 디스크를 엑세스하는 경우 (플레이 도중)
-> 비동기 프로그램으로 하자.. (멀티쓰레딩 말고..) 
비동기 I/O 혹은 Overlaped I/O
3. 기기에 있는 CPU(다른 말로 Core)를 모두 활용해야 할 때 --> 이건 맞음

4. 프로그램을 모듈화 하여 다른 쓰레드에서 독립적으로 실행 --> X

**Single Core의 사용량이 100퍼가 되지 않았다면 멀티쓰레드 프로그래밍을 절대로 하면 안된다!!**

CPU 사용량 = 100퍼 / 논리 프로세서 갯수.


array보다는 vector...

동시에 실행하면 문제가 생길것이다. => 

스레드에서 어떤 정보 X를 사용하고 있는 동안 다른 스레드는 X를 건드리지 못하게 해야함 
===>> 상호배제(Mutual exclusion)의 줄임말

# 임계 영역과 뮤텍스

lock_guard<recursive_mutex> => lock시에 unlock을 할 필요가 없음
==> 변수가 사라지면 알아서 unlock을 해준다.

lock unlock으로 인해 완벽하게 병렬화 하지 않았기 때문에 속도 차이가 딱 정확하지 않다.

하이퍼 쓰레드 -> 2배 빠르다? ㄴㄴ 20퍼센트 빠르다

lock을 하고 unlock을 하지 않으면 데드락이 발생한다.

recursive_mutex => 원래는 lock을 건 내가 또 lock걸면? deadlock 인데 이걸 막아준다. 자신이 또 lock하면 				unlock	근데 mutex보다 느리다. 쓰지 말자.

* 뮤텍스를 너무 잘게 나누면?
- mutex가 많아지면 성능이 떨어짐
- lock이 많아지면 데드락이 걸린다.

*게임 서버에서 교착 상태가 되면 발생하는 현상
Prevent Avoid Detection를 고수해야한다..

CriticalSection => 윈도우에서 사용하는 lock이다. => 옛날 방식 => mutex를 쓰자...
임계 영역 생성은 mutex로 객체 생성
임계 영역 제거는 mutex로 객체 제거
임계 영역 잠금은 lock() 호출
임계 영역 잠금 해제는 unlock()호출

# 잠금 순서 ==> 데드락 회피

데드락의 네가지 조건?
락을 걸때 순서를 지킨다.
1.
2. 
3.
4. 

# 교착 상태

--> 디버깅 실행 -> 중단 -> 디버그 -> 창 -> 스레드 를 하면 돌아가고 있는 스레드를 볼 수 있다.
 
- 만약 모든 쓰레드가 lock()에 중단점이 걸려 있다면 데드락에 걸린 상태이다.

암달의 저주? => 암달의 법칙 : 프로그램이 있을때 병렬로 90퍼 직렬 10퍼면
			 성능 향상이 의미가 없다? 
=> 이유? => Lock Unlock 때문 => CPU가 노니까.