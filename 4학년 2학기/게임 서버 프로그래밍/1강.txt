게임서버 프로그래밍

교재 : 게임 서버 프로그래밍 교과서 
	길권출판사 > 저자 : 배현직

--> 텀프로젝트 = 숙제 + 컨텐츠

1. 멀티 스레드 프로그래밍

스레드 -> 프로그램이 실행되면 Process 되어 실행되고 이것을 운영체제가 관리
(다른 의미로 Context라고 한다. <- 실행, 문맥, 맥락)
Context->CPU 내부상태

프로그램 --실행--> 프로세스(OS)(스레드관리)

하나의 프로세스 스레드를 여러개 가지고 있을때 -> 멀티스레드 


*실행과정

#Program

func();

main()
{
시작
---->
...
func();

끝
}
{싱글스레드(실)->한 흐름}

#Program

func()

main()
{
createthread() -> 가지치기
...
}
{멀티스레드(여러실)->여러 흐름}

멀티스레드 프로그래밍을 하면 하나의 프로그램에서 동시에 여러 작업을 수행 시켜 줄 수 있다.


프로그램 -> 작업을 나누어서 별도의(여러개의) thread core에서 수행

1000개의 작업  	-> 500개의 작업 -> thread 1	  
    {위 아래 스레드는 공유, 동기화(Syncronization), 통신을 한다.}
		-> 500개의 작업 -> thread 2

즉, 작업을 나누어 동시에 작업시켜 더 빠르게 해준다.


게임로직 스레드, 사운드 스레드, 물리 스레드, 인공지능 스레드, 렌더링 스레드

서로 연관(연결)이 되어 있기 때문에 서로 데이터를 주고 받아야 올바른 렌더링을 한다.

IPC (Inter Process Communication)

이 프로세스에 이 데이터를 주세요 -> 등등 -> 운영체제에서 해야됨.
하지만 운영체제 System Call은 Overhead가 크기 때문에...

EX)
A thread		B thread
a = 3;		cout << a;

A process		B process
sendmessage(B, 3)	receivemessage(A, &x)

아래는 위보다 1000배 이상 느리다.
운영체제 System Call은 Overhead가 크기 때문에...

동시에 프로세스를 해서 실행 속도를 올린다.


*메모리를 여러개 조각으로 나눠서 쓰는것이 통째로 크게 쓰는것 보다 좋다.

			Process

Code Segmentation		CODE(실행코드)
			
			DATA(전역변수)
	
			HEAP(new delete, malloc, free)
	
			STACK(지역변수, 함수 복귀주소, 
				함수 매개변수)

멀티 스레드를 사용하기 위해서는 이 구조를 알아야 한다.


Thread 0 		Thread 1

CODE		<-공유

DATA		<-공유

HEAP		<-공유

STACK 0		STACK 1


예를들어 집이 멀티 스레드이면 방 하나하나가 STACK들이라고 생각하면 된다. STACK(자기만 사용하는 데이터를 넣는다.), STACK에 있는 데이터를 공유하는 방법은 없고 그러면 안된다. 왜냐면 STACK은 지역변수를 벗어나면 메모리가 날라가기 때문이다.

# 그러면 멀티쓰레드 프로그래밍은 언제? 왜 해야하는가?

프로그램이 느려서 한다!

프로그램이 느린 이유?
--> 잘못된 알고리즘을 써서 -> 좋은 알고리즘을 써서 대체
--> I / O 작업을 해서  1.-> 좋은 하드웨어를 쓴다.
		  2.-> I / O 횟수를 줄인다. I / O 데이터양을 감소
		  3.-> 비동기 I / O Asynch (동시에 읽자!)
위 원인들은 멀티쓰레드로 해결해도 의미가 없지만...
--> CPU가 느리다! -> 멀티쓰레딩!  

1. 큰작업이 있고 작은 작업이 있을때  
2. 작은 작업들을 빨리 실행해야 할때
3. 프로그램을 모듈화 해서 보기 좋게 만들고 OOP 개념을 도입
4. 등등

위 때문이라면 절대 멀티쓰레드로 해결하면 안된다!!
왜 쓰면 안됨? -> goto문 처럼 위험해서... -> 되도록이면 사용 X

위의 것들을 시도 해보고 정 안되면... 그때 멀티 쓰레드를 쓴다.

근데 게임서버는 동시접속이 중요하기 때문에 멀티 쓰레드가 꼭 필요하다.

->클라이언트 프로그래머도 이제는 멀티쓰레드 프로그래머가 필요하다..!


# 멀티스레드는 운영체제를 통해서 해야 한다...

thread ---> kernel level thread (운영체제가 관리)

         { ---> User level thread (program자체 관리) } 이건 안씀

다른 코어에 할당하려면 운영체제에서 해줘야 하기 때문에 
-> kernel level thread를 멀티스레드에 사용

이미 구현된 스레드를 사용해야 한다. 운영체제를 통해서

window.h 
CreateThread 
	
Linux 
pThread_Create

-> 위 방법은 Old하다...

그래서 C++11을 사용하여.. 왜? 표준이니까..

#include <thread>

std::thread -> 실행 Context

void func_1()
{
}

main()
{
std::thread t1{func_1(함수포인터(실행객체, 람다)를 넣자.)}
std::thread t2{(...)}
}


#운영체제

멀티프로세싱

동기화
-lock()
-unlock()
X 세마포어() -> 이걸 사용하려면  System Call을 해야한다.
X 모니터()	   -> 이것도 마찬가지
=> X데드락 --> 데드락 걸리면 

#include <mutex<

std::mutex my_lock;

my_lock.lock();
my_lock.unlock();






















