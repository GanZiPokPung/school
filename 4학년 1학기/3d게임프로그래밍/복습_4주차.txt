# 벡터(Vector)

벡터의 정규화 : 크기가 1이 아닌 벡터를 크기값 만큼 나누어 단위벡터로 만든다.
단위벡터(Unit Vector) = 크기가 1인 벡터.
단위 벡터는 다각형이 향하는 방향벡터를 구하기 위해서 사용될수 있다.

물체가 향하는 방향 단위 벡터 * 스칼라(거리) = 거리 만큼 움직임

벡터의 스칼라곱 : 음수로 스칼라곱을 한다면 방향이 180도로 전환된다.
A <-- B : A - B

# 외적

*벡터의 외적 : 두 벡터의 외적 연산의 결과는 두 벡터의 각각 수직인 벡터이다.
A X B = C
>> A는 C와 수직, B는 C와 수직
왼손 법칙에 의해서 나머지 한 손가락이 외적의 결과가 된다.

외적은 교환법칙이 성립하지 않으므로 외적의 순서에 따라 값이 달라진다.
a x b = -(b x a)
|a x b| = |a||b|sin0

점 2개  --> 벡터로 표현 가능

*법선 벡터
면의 수직인 벡터, 방향을 나타내는 단위벡터
면의 v0v1 x v0v2 접선벡터의 외적이 카메라를 바라보고 있으면 전면
바라보지 않는다면 은면이다.
접선(v0v1 etc)에 수직인 벡터

Method 
CVector GeneratePolygonNormal

*회전에 필요한것
1. 회전의 중심
3D : 모델좌표계 원점의 축(외적을 통해 축을 직접 찾을 수도 있음)
2D : 원점

2.회전의 각도
내적을 통하여 얼마나 회전을 해야할지에 대한 각도를 구할 수 있다.

*외적의 용도
1. 삼각형의 법선 벡터를 구하기 위함
2. 회전축을 찾아 내기 위함

# 내적
*내적 연산에서 두 벡터는 같은 시작점을 가져야 한다.

*내적의 결과는 스칼라 값(실수)로 나온다.

*내적의 결과를 이용하여 두 벡터가 이루는 각도를 구하는 법
A*B = |A|*|B|cos0
cos0 = (A*B)/|A|*|B|
0(두 벡터의 사이값(세타값)) = acos((A*B)/|A|*|B|)

*A와 B벡터가 수직일때 내적의 결과는 0이다.
*A와 B벡터가 이루는 각이 예각일 경우에는 내적의 결과는 양수이다.
*A와 B벡터가 이루는 각이 둔각일 경우에는 내적의 결과는 음수이다.

A*A = |A|^2

#직교투영(Orthogonal Projection)
p(Projection Vector) = (|v|cos0)n = (v*n)n
q = v - p
(ppt 하단 그래프 참고)
Rejection Projection
어느 한 벡터의 수선의 발을 내렸을때의 선분에 대한 벡터(p)를 구할 수 있다.
그리고 구한 선분을 사용하여 수선의 발에 대한 벡터(q)를 구할 수 있다.

사용처 >> 대포가 날라가다가 수직 강하 할때????

#반사벡터(Reflection Vector)
한 면의 법선 벡터(n)을 알고 있을때 면을 향하는 임의의 벡터(v)에 대한 반사벡터(r)을 구할 수 있다.
r = v + (-2(v*n)n)

사용처 >> 당구게임

#굴절절벡터(Refraction Vector)
알파 베타 -> 두 물질의 투과율 -> 굴절율
ㅅ = a/b
k = sqrt(1-ㅅ^2 * (1 - (-(v*n))^2))
t = (ㅅv) + (ㅅ(-(v*n)) - k)n

#스칼라 삼중적(scalar triple product)

u*(dxv) > 0 : d는 v의 왼쪽 (최단 회전은 반시계 방향)
u*(dxv) < 0 : d는 v의 오른쪽(최단 회전은 시계 방향)

각도에 따라 회전 방향을 정해줄 수 있다. (최선의 회전)
이 작업을 안하면 회전 방향은 항상 한 방향이 될 것이다.

*외적의 결과에서 부호를 검사하면 어느 방향으로 움직일 지를 알아낼 수 있다.

(dxv) > 0 왼
(dxv) < 0 오

#극 좌표와 구면 좌표
*극 좌표(2차원) 원 위의 점
*구면 좌표(3차원) 구 위의 점

사용처 >> 행성 위 지형 태우기

#평면

평면은 3D공간에서 무한히 확장하는 무한히 얇은 면이다.

평면의 법선 벡터가 원점에서 멀어지도록 향하고 있다 --> 원점은 평면 뒤 (거리는 음수)
평면의 법선 벡터가 원점을 향하고 있다 --> 원점은 평면 앞 (거리는 양수)

*평면의 법선벡터
*평면까지의 거리
거리 계산을 위해 내적을 사용


법선 벡터(단위벡터) 혹은 평면 위의 점이 주어지면 구할 수 있다.
ex) 폴리곤 --> 폴리곤의 점 혹은 폴리곤 벡터의 외적(법선 벡터)

원점에서 평면까지의 거리를 계산하기 위하여 두 개의 벡터가 필요.
1. 평면의 법선벡터
2. 원점에서 평면 위의 점까지의 벡터

#평면의 방정식
(ax, by, cz)는 법선 벡터와 점 (x, y, z)의 내적이다.
ax + by + cz + d = 0 <-----> (p, q, r)

ap + bq + cr + d 에 대해서    양수 -> 평면 앞의 점
			음수 -> 평면 뒤의 점
			0     -> 평면 위의 점

사용처 >> 당구 큐대에 부딪힌 체크

*점과 평면과의 위치 관계

P1에서 P2와 내적의 결과 >> 양수
P1에서 P4와 내적의 결과 >> 예각
P1에서 P3과 내적의 결과 >> 음수

*평면까지의 거리
임의의 한 점에서 평면까지의 거리

법선벡터 * (평면의 한 점 - 임의의 한 점) 
하면 거리를 구할 수 있다. (내적으로 거리구함)

*은면 제거
A Front Face, Back Face

다각형의 법선 벡터가 카메라를 향하면 --> front(시계 방향의 다각형)
다각형의 법선 벡터가 카메라를 향하지 않는다면 --> back(반시계 방향의 다각형)

다각형이 카메라를 향하는 가를 결정하기 위해서 내적을 사용할 수 있다.

(카메라 - 다각형의점) * 다각형법선벡터 < 0 --> front
(카메라 - 다각형의점) * 다각형법선벡터 > 0 --> back

#행렬(Matrix)

행과 열로 배열된 표
m x n 행렬

v(Vector)M(Matrix) = v'(Trans Vector)
vM = v'

왼손 좌표계의 기준이므로
(1 * 3) * (3 * 3) = (1 * 3)

*단위행렬 : 변화가 없는 행렬


*크기 변환 행렬 : 행렬의 스칼라곱
(x, y, z) --> k(x y z)

*회전행렬 : 축에 따라 행렬의 표현이 다르다.

*역행렬 : 역행렬은 즉 역변환!

*평행이동과 역행렬

*회전행렬과 역할렬

*행렬의 곱의 결합법칙 성립
-> 순서가 같으면 뭔짓을 해도 연산 결과는 같다.

A*B    = C
(vA)*B = vC

벡터와 행렬의 곱 : 15번 연산
n = 4, i = 10000
(15 * 4) * 10000 = 600,000

n = 10, i = 10000
(15 * 10) * 10000 = 1500,000

행렬과 행렬의 곱 : 45번 연산
n = 4, i = 10000
(45 * 3) + 15 * 10000 = 150,135 

n = 10, i = 10000
(45 * 10) + 15 * 10000 = 150,405

변환을 행렬로 처리하면 효율적이다!!
행렬의 곱의 성질을 잘 이용하면 계산량을 줄일 수 있다!

*평행이동
(X, Y, Z) = (x+a, y+b, z+c)
평행이동은 3x3 행렬로 표현이 불가능하다. 왜?
지구상에서는 해결을 못하는 문제.

*동차 좌표계
이런 문제를 해결하기 위해서!!
차원을 4차원으로 늘리겠다!!!
(X, Y, Z, W)
4차원으로 늘린 후 평행이동을 수행하고 3차원으로 바꾼다.
4차원의 W가 1일때에 3차원 좌표와 동일하기 때문에 W를 나눈다.(투영)
W가 1인 4차원 벡터는 3차원 벡터로 직접 대응된다.
(X, Y, Z, 1)은 (X, Y, Z)와 동차이다.

행렬도 4x4로 되어야 한다.
4열은 항상 (0, 0, 0, 1)
4행은 평행이동을 담당한다. 

* 평행이동 (변환) 행렬
* Z축 회전과 평행이동

* 좌표계 변환의 행렬 표현
결과를 알면 그 결과를 반영하는 행렬을 만들 수 있다.

*행렬의 행은 축을 나타낸다*
위치를 표현(점)	: W가 1 --> 4행이 0이 된다.
방향을 표현(벡터) 	: W가 0 --> 4행에 값이 들어온다.

# 월드 변환 행렬

CObject -> 월드 좌표계에서 객체의 위치와 방향을 나타내기 위하여
하나의 행렬을 사용

class CObject
{
	CMesh 	*m_pMesh;
	MATRIX  m_WorldMatrix;
};

* 월드 변환 행렬
  1행 Right 	Vector
  2행 Up 	Vector
  3행 Look 	Vector
  4행 Position	Vector

오브젝트의 모델좌표계 축은 월드변환시 회전을 하면 값이 바뀔수 있다.

4행 -> 위치
나머지행 -> 방향

왼손좌표계	기존행렬 M
오른손좌표계 	전치행렬 M^T

#카메라 변환 행렬

카메라 변환 행렬 ==> 월드 변환 행렬의 역행렬

*직교행렬의 역행렬은 그 행렬의 전치행렬과 같다.
M^-1 = M^T

구조체는 행렬이 아니라 벡터 4개로 되어있다.
--> Why? 벡터 4개를 사용해 한꺼번에 행렬로 만들어줄 수 있기 때문 
	(또한 이것이 더 빠르다)

D3DXMatrixLooaAtLH --> D3DXMatrixInverse(역행렬) 보다 빠르다.

pEye -> World Pos
pAt -> Look Pos
pUp -> Up Vector(Normaly(0, 1, 0))

카메라에 하나의 벡터만 있으면 나머지 두 벡터는 그저 외적만 해주면 구할 수 있다.

*행렬의 집합

행렬의 결합법칙을 이용하여
((((vector * World) * View) *Projection) * Screen))
= v * (W * V * P * S) = v * M

계산량을 줄이는 방법이다.

*충돌검사

월드 좌표를 로컬(모델)좌표로 역변환(World -> Local) (효율적인가?)
모델의 정점들의 월드 좌표를 알기 위해서는 모델 로컬 좌표 * 월드 변환 행렬

#원근 투영(Perspective Projection) 변환 행렬

화면 좌표계에 늘어나는 비율만큼 투영 좌표계에서 줄여(조정하여)준다.

*원근 투영 변환
원근 투영 나누기(z나누기)를 하기 전에 메쉬를 왜곡시키자.

*투영 변환 행렬
변환된 벡터의 w요소 -> W-버퍼, 깊이 기반 안개 등 (원래의 z값)
변환된 벡터의 z요소 -> 깊이 값(Depth, 0 ~ 1.0)

(x, y, z, 1) => (X, Y, Z=depth buffer value, W = z)

쓰는 경우 
1. FOV가 90도가 아닐때
2. 가로가 늘어나는 문제(Scaling)

1해결법 -> 임의의 FOV각도를 위한 투영 변환 행렬 1 / tan(seta)
					seta = (FOV각도) / 2

2해결법 -> 화면의 가로가 세로보다 긴 것을 해결하는 투영 변환 행렬

cotan(seta) = 1 / tan(seta) 

투영 변환 행렬 1행 1열 2행 2열에 1 / tan(seta) ---> 임의의 FOV각도를 위한 투영 변환 행렬
(seta = (FOV각도) / 2)

R = 가로 길이 / 세로 길이 = 종횡비(Aspect Ratio)

그리고 화면의 가로가 세로보다 긴 것을 해결하는 투영 변환 행렬
x축인 1행 1열에 {1/tan(seta)} / R가 된다.


*D3DXMatrixPerspectiveFovLH
원근 투영 변환 행렬을 생성한다.


3행 3열에는 z(f) / (z(f) - z(n))이
4행 3열에는 -z(n)z(f) / (z(f) - z(n))이 들어간다.

그 이유는 밑과 같다.
벡터와 연산해줄때
(x, y, z, 1) * PM = (x * xScale, y * yScale, (z - z(n)) * z(f)/(z(f) - z(n)), z)

z값은 (z - z(n)) * z(f)/(z(f) - z(n))가 나온다.

(z가 near(z(n))일때) --> (z(n) - z(n)) * z(f) / (z(f) - z(n)) = 0 -z나누기-> 0 / z = 0 
(z가 far(z(f))일때) --> (z(f) - z(n)) * z(f) / (z(f) - z(n)) = z(f) -z나누기-> z(f) / z = 1.0

z축을 나누어 구한 최종값이 near와 far기준에 따라 0 ~ 1.0사이가 나오도록 유도해주는 식이다.

near < 0 --> near보다 더 가까이 있는것
far > 1   --> far보다 더 멀리 있는것