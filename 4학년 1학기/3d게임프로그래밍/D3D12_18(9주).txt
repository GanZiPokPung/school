Direct3D Graphics Pipeline(Part 1)

Direct3D가 제공하는 파이프라인
1. 그래픽스 파이프라인
2. 계산 파이프라인

* Direct3D 9 파이프라인

* Direct3D 12 파이프라인

* Direct3D 렌더링 파이프라인
Render Target에 2D 이미지 -> rendering

page 3 -> 가지고 다니면서 봐야함..

입력 조립기, 테셀레이터, 래스터라이저, 출력 병합기 등은 바꿀 수 없음
쉐이더들 -> 비어있으므로 사용자가 함수들을 집어넣어 완성이 필요하다.

그래서.. 두가지로 나눌것이다.

-고정 프로그램 단계
* 입력 조립 단계(IA : Input Assembler)
* 테셀레이터 단계(TS : Tessellator Stage)
* 스트림 출력 단계(SO : Stream Ouput Stage)
* 래스터라이저 단계(RS : Rasterizer Stage)
* 출력 병합 단계(OM : Output Merger Stage)

-프로그램 가능 단계
* 정점 쉐이더 단계(VS : Vertex Shader Stage)
* 헐 쉐이더 단계(HS : Hull Shader Stage)
* 도메인 쉐이더 단계(DS : Domain Shader Stage)
* 기하 쉐이더 단계(GS : Geometry Shader Stage)
* 픽셀 쉐이더 단계(PS : Pixel Shader Stage)
-> 추가로 계산 쉐이더 단계(하지만 2학기때 다룰것이다.)

각각의 단계를 함수라고 생각하면 된다.

파이프라인은 항상 고정되어 있고 사용자는 그저 들어가는 파라미터만 바꾼다.
-> 이러한 작용을 Set이라고 한다.

파이프라인은 연결이 되어서 동작 한다! (순서는 외워야함)

* Direct3D 디바이스
-> IA 부터 OM 까지의 단계를 표현 해놓은거다..!

* 입력-조립 단계 (Input Assembler Stage)
단계에 Set을 하고 Draw를 하라고 하면 그때 파이프라인단계가 순차적으로 실행된다.

IA는 -> 입력 리소스 
모델 데이터(메쉬, 정점들의 배열 등)을 입력 리소스라고 할 수 있다.

1. 정점 데이터 
2. 프리미티브 : 정점 이용해서 어떻게 그릴것인지를 정할 수 있게 해준다.
그림을 그리기 위한 기하학적 데이터라고 할 수 있겠다.
(선 리스트, 삼각형 리스트, 삼각형 스트립, 인접성을 가지는 프리미티브 등)

점들을 가지고 조립해줘야 한다.

-시스템 생성 값(System-Generated Values)을 추가

조립을 위한 데이터 -> 배열 -> IA넣어주면 -> 조립 -> 다른 단계에서 출력하기 위					  한 정보를 순차적으로 흘려보냄 
			(이 작업은 각각 프리미티브 개수 만큼 반복 실행된다)					

시스템 생성 값은 시멘틱(Sementic)이라고 하는 문자열의 값을 사용한다.

IA가 넘겨준 값들은 VS의 파라미터로 들어간다.

쉐이더 변수에다가 꼬리표를 달아준다. -> 문자열을 달아준다.

ex) float f1, f2, f3 ...
    f1 : (문자열)(꼬리표)

시스템 생성 값은 SV로 시작한다. -> 의미가 정해져 있다.
SV_PrimitiveID, SV_InstanceID, SV_VertexID

프리미티브를 이용해 조립하고 그것을 파이프라인에 흘려보내어 프래그먼트를 만들고 그것을 픽셀화 해주는 작업을 해줄 수 있다.

항상 Draw를 해야만 파이프라인이 동작한다!

* 래스터라이저 단계
래스터라이제이션
프리미티브 정보들을 픽셀들의 정보로 바꾸는 단계이다.

래스터라이제이션 
보간(Interpolation)

-원근 투영 나누기(z 나누기)
-카메라 절두체를 벗어나는 점(픽셀)들을 클리핑(Clipping)
-2d 점들(투영 변환까지 완료) 뷰포트로 매핑 RSSetViewport 
-프리미티브의 모든 픽셀들에 대하여 픽셀 - 쉐이더를 호출

래스터라이져는..
투영변환 -> 화면변환을 담당

*래스터라이저 단계에서 픽셀의 속성 계산
보간을 하면 보간을 하려는 점들을 알고 있다면 모든 위치를 알 수 있다.
마찬가지로 픽셀 색상도 내부 색상을 알 수 있다.
예) 빨강과 녹색을 보간 -> 중간지점 노란색

-> 뷰포트 정보가 있으면 화면 픽셀을 찾아낼 수 있다.

래스터라이저의 중요한 단계 2가지
1. 래스터라이제이션
2. Interpolation을 통해 픽셀 정해줌

VS(Vertex Shader)
정점(모델 데이터)에 대해서 어떤 일을 하는 단계.

OM가 Depth Buffer 알고리즘 사용

VS에서 원근 투영 변환 까지 해주어야 RS에서 원근 투영 나누기를 적절히 수행

* 출력 병합 단계(Output-Merger Stage)
각 픽셀에 대한 깊이-스텐실 검사와 블렌딩 연산을 수행하여 최종 출력 색상을 결정

-깊이-스텐실 검사(Depth-Stencil Testing)
-블렌딩(Blending)
두개의 색을 Depth값에 상관없이 섞는 방법

이 두가지 작업을 OM에서 한다.

* Direct3D 쉐이더 단계

블랜딩 -> 투명처리를 위해 필요

블랜딩은 Depth Test를 쓰면 안된다.

PS는 -> 픽셀 색상을 결정하는 단계

사용자의 파라미터 -> IA에서 모델 데이터 넘겨줌 -> 입력 데이터 -> 쉐이더 코드 
(VS, PS etc..) -> 출력 데이터

6개의 정점을 이용해 삼각형 두개를 그린다고 가정
-> IA(프리미티브 2개) -> VS -> RS(6번) -> PS(6번) 
항상 6번 불리지는 않음.

오로지 쉐이더코드에만 Resource를 Set가능하다.
메모리 리소스(Memory Resource) 
-상수 버퍼(Contant Buffers)
-텍스쳐(Texturers) --> Set하기 전 Sampler 단계 필요.
-버퍼(Buffers)

쉐이더 모델 4(Shader Model 4)
-> 하나의 쉐이더에...
16개 샘플러
128개 텍스쳐와 버퍼
16개 상수 버퍼 연결 가능

* 정점 쉐이더 단계
모든 정점에 대한 모든 Transform을 해야 하는 단계.

Transformation이 기본이고...
필요에 따라 Skinning, Morphing, 조명(Vertex Lighting)

두개의 시스템 생성 시멘틱을 사용할 수 있음
SV_VertexID
SV_InstanceID

* 픽셀 쉐이더 단계
픽셀 하나에 대해서 픽셀 쉐이더가 한번 호출 된다.
그리고 픽셀 쉐이더는 색깔이 리턴 되어야 한다.

* 그래픽 파이프라인 상태의 생성
픽셀 쉐이더의 호출 개수는 레스터라이저에서 정점을 받아 처리한 픽셀의 개수 만큼이다.

픽셀 쉐이더 -> Lighting 계산이 프레임 레이트에 영향을 미칠 수 있다.
그래서 조명 계산을 VS에서 한다. (멀리있는것 -> 조명 계산 X)



 



