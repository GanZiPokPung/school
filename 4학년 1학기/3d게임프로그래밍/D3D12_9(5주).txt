d/z => 1 / tan(seta)
(1/tan(seta)) / screen ratio


z나누기 후 0 ~ 1.0까지 --> Depth라고 부를 것이다.


(x, y, z, 1) --PM--> (x, y, z, z) --Z나누기--> (x/z, y/z, 1, 1)

# D3DXMatrixOrthoLH (직교투영, 정사영투영)

z축에 평행하게 투영이 된다.
z나누기를 하지 않음

사용되는 곳 --> UI

#화면 좌표 변환 행렬

*뷰포트
투영된 사각형 영역 ---> 픽셀화

*화면 좌표 변환 행렬
x, -y는 투영된 사각형의 각 축

행렬로 연산을 하는 이유 --> 수학적으로 좋은 성질을 가지고 있기 때문에

#화면 좌표 변환 행렬

*화면 좌표의 역변환

픽킹(Picking)
화면 좌표 --> 화면 역변환(역행렬) --> 투영 역변환 --> 카메라 좌표

Z축 나누기를 안하면 3D

투영 사각형은 어떤 사각형이던 모든 점들은 z좌표가 1이다.

z는 1

*픽킹

위를 통해 우리는 x, y, z == 1을 찾아 냈다.

이제 z축으로 직선으로 쭉 뻗었을때 존재하는 모든 점들 중에서 가장 가까운 점이 있을때 그것이 픽킹하는 점

*DirectX 뷰포트

*화면 좌표 변환 행렬
(MaxDepth - MinDepth) 
MinDepth

#Quiz

변환 좌표계 

변환과 역변환 둘다 가능하다.

Chapter 00  끝

#Soft Rendering(Scene)
살펴보기

Chapter 00 DirectX Math

D3DXPlaneFromPointNormal -> 점, 법선벡터 => 평면
D3DXPlaneFraomPoints -> 점 3개 => 평면
D3DXPlaneDotNormal -> 법선벡터, 평면을 내적
a*x + b*y + c*z + d*0
(평면의 법선 벡터와 벡터 (x,y,z)의 각도 cos값)
D3DXPlaneDot -> 평면, 벡터 내적
a*x + b*y + c*z + d*w
(평면과 벡터(x,y,z,1)와의 위치 관계, 부호로 판별)
D3DXPlaneNormalize
평면의 법선 벡터(a, b, c)의 크기로 a,b,c,d를 정규화
D3DXPlaneIntersectLine

D3DXVec3TransformCoord(위치)
벡터(x,y,z,1)와 행렬(4x4)의 곱, 결과 벡터를 3차원 벡터로 바꿈(Homogenizing)
D3DXVec3TransformNormal(방향)
법선 벡터(x,y,z,0)와 행렬의 곱, 결과 벡터를 정규화 한다.
D3DXVec3Transform
벡터와 행렬의 곱셈

D3DX --> Direct9, 10에서 사용하던것
왜 사용 안함? ->                                                                                                                    






