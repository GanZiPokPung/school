#월드 변환 행렬

4행 -> 위치
나머지행 -> 방향

왼손좌표계  	기존행렬  M 
오른손좌표계  	전치행렬  M^T

#카메라 변환 행렬

카메라 변환 행렬 ==> 월드 변환 행렬의 역행렬

*직교행렬의 역행렬은 그 행렬의 전치행렬과 같다.
M^-1 = M^T

구조체는 행렬이 아니라 벡터 4개로 되어있음. 
--> Why? 벡터 4개를 사용해 한꺼번에 행렬로 만들어줄 수 있기 때문
	(또한 이것이 더 빠르다)


D3DXMatrixLookAtLH --> D3DXMatrixInverse(역행렬) 보다 빠르다.

pEye -> World Pos
pAt  -> Look Pos
pUp  -> Up Vector (Noramly (0, 1, 0))

카메라에 하나의 벡터만 있으면 나머지 두 벡터는 그저 외적만 해주면 구할 수 있다.



*행렬의 집합

행렬의 결합법칙을 이용하여
((((vector * World) * View) * Projection) * Screen))
 = v * (W * V * P * S) = v * M

계산량을 줄이는 방법이다.

*충돌 검사

월드좌표를 로컬(모델)좌표로 역변환(World -> Local)(효율적인가?)


#원근 투영(Perspective Projection) 변환 행렬

화면 좌표계에 늘어나는 비율만큼 투영 좌표계에서 줄여(조정하여)준다.

*원근 투영 변환
원근 투영 나누기(z나누기)를 하기 전에 메쉬를 왜곡시키자.

*투영 변환 행렬
행렬의 w요소 --> W-버퍼(원래의 Z값을 저장한다.)

쓰는 경우
1.FOV가 90도 가 아닌 경우 
2.가로가 늘어나는 문제 (Scaling 하면 된다.)


1 해결위해 : 임의의 FOV각도를 위한 투영 변환 행렬
 		1 / tan0
		0 = (FOV각도) / 2

2 해결위해 : 화면의 가로가 세로보다 긴 것을 해결하는 투영 변환 행렬

R = 종횡비(Aspect Ration)

{1/tan(0)} / R

*D3DXMatrixPerspectiveFovLH
원근 투영 변환 행렬을 생성한다.

z축을 나누어서 구한 최종값 0 ~ 1.0사이
near : 0보다 작음, 
far : 1보다 큼

OpenGL은 오른손 좌표계를 기준으로 하므로 0 ~ 1.0이 아니다.

