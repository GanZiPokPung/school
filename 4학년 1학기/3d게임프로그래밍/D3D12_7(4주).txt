1. 벡터(Vector)

벡터의 정규화 : 크기값 만큼 나눔
벡터의 스칼라곱 : 음수로 스칼라곱 (방향 180도 전환)
A <-- B : A - B

# 외적
벡터의 외적 : 두 젝터의 외적 연산의 결과는 두 벡터의 각각 수직인 벡터이다.
A X B = C
>> A는 C와 수직, B는 C와 수직
왼손 법칙에 의해 나머지 한 손가락이 외적의 결과가 된다.

외적은 교환법칙이 성립하지 않으므로 외적의 순서에 따라 값이 달라진다.
a X b = -(b X a)

*점 2개 => 벡터로 표현이 가능하다.

법선 벡터 (Normal Vector)
*면의 v0v1 X v0v2 접선벡터의 외적이 카메라를 바라보고 있으면 전면 바라보지 않으면 은면이다.
*접선(ex. v0v1)에 수직인 벡터

Method
CVector GeneratePolygonNormal

회전에 필요한것
1.회전의 중심
3D : 모델좌표계 원점(혹은 외적을 통해 회전축을 직접 찾을 수 도 있음)
2D : 원점
2.회전의 각도
내적을 통하여 얼마나 회전을 해야할지에 대한 각도를 구할 수 있다.

외적의 용도
1.삼각형의 법선 벡터를 구하기 위함
2.회전축을 찾아 내기 위함

#내적
*내적의 결과는 스칼라 값(실수)로 나온다.

*내적의 결과를 이용하여 두 벡터가 이루는 각도를 구하는 법
A*B = |A|*|B|*cos0
cos0 = (A*B)/|A|*|B|
0(두 벡터의 사이값(세타값)) = acos((A*B)/|A|*|B|)

*A와 B벡터가 수직일때 내적의 결과는 0이다.
*A와 B벡터가 이루는 각이 예각일 경우에는 내적의 결과는 양수이다.
*A와 B벡터가 이루는 각이 둔각일 경우에는 내적의 결과는 음수이다.

A*A = |A|^2

#직교투영(Orthogonal Projection)
p(Projection Vector) = (|v|cos0)n = (|v||n|cos0)n = (v*n)n
q = v - p
(ppt 하단 그래프 참고)
Rejection Projection
어느 한 벡터의 수선의 발을 내렸을때의 선분에 대한 벡터(p)를 구할 수 있다.
그리고 구한 선분을 사용하여 수선의 발에 대한 벡터(q)를 구할 수 있다.

사용처 >> 대포가 날라가다 수직강하 할때?

#반사벡터(Reflection Vector)
(ppt 그림 참고)
한 면의 법선 벡터(n)을 알고 있을때 면을 향하는 임의의 벡터(v)에 대한 반사벡터(r)을 구할 수있다.
r = v + (-2(v*n)n)

사용처 >> 당구게임

#굴절벡터(Refraction Vector) 
(ppt 그림 참고)
알파 베타 -> 두 물질의 투과율 -> 굴절율

#스칼라 삼중적(scalar triple product)
각도에 따라 회전 방향을 정해줄 수 있다.(최선의 회전)
이 작업을 안하면 회전 방향은 항상 한 방향이 될 것이다.

(ppt 그림 참고)
*외적의 결과에서 부호를 검사하면 어느 방향으로 움직일 지를 알아낼 수 있다.
u*(dxv) > 0 : d는 v의 왼쪽(최단 회전은 반시계 방향)
u*(dxv) < 0 : d는 v의 오른쪽(최단 회전은 시계 방향)

(dxv) > 0
(dxv) < 0


#극 좌표와 구면 좌표
*극 좌표(2차원)  원 위의 점
*구면 좌표(3차원) 구 위의 점

사용처 >> 행성 위 지형 태우기 가능?

#평면
*평면의 법선벡터
*평면까지의 거리
법선 벡터(단위벡터형태) 혹은 평면 위의 점이 주어지면 구할 수 있다.
ex) 폴리곤 --> 폴리곤의 점 혹은 폴리곤 벡터의 외적(법선 벡터)
#평면의 방정식
||(a, b, c)|| = sqrt(a^2 + b^2 + c^2)
ax + by + cz + d = 0(정규화 되어있는)
(ppt 참고)
n*(p-q) = 0
ax + by + cz - (ax0 + by0 + cz0) = 0
ax + by + cz + d = 0
d(원점에서 평면까지의 거리) = -(ax0 + by0 + cz0) 

(-q) * (-n) = (x0, y0, z0) * (a, b, c) = D
ax0 + by0 + cz0 = D
d = -(ax0 + by0 + cz0) = -D

*평면 뒤에 모든 점들에 대한 평면까지의 거리는 음수의 값을 가질 것이다.

#평면의 방정식

(a, b, c)는 법선벡터
(ax, by, cz)는 법선 벡터와 점 (x, y, z)의 내적이다.
ax + by + cz + d = 0 <-----> (p, q, r)

ap + bq + cr + d 에 대해	양수 -> 평면 앞
		       	음수 -> 평면 뒤

사용처 >> 당구 큐대 부딪힌 체크

*점과 평면과의 위치 관계
P1 내적의 결과 >> 0
P2 내적의 결과 >> 예각
P3 내
*평면까지의 거리


은면 제거
A Front Face,  Back Face

*한 점이 다각형 내부의 점인가?


#행렬(Matrix)

v(Vector)M(Matrix) = v'(Trans Vetor)
vM = v'

왼손 좌표계의 기준이므로
(1 * 3) * (3 * 3) = (1 * 3)

*단위행렬 : 변화가 없는 행렬
*크기 변환 행렬 : 행렬의 스칼라곱
(x, y, z) --> k(x y z)

*회전행렬 : 축에 따라 행렬의 표현이 다름

*역행렬 : 역행렬은 즉 역변환!

*평행이동과 역행렬

*회전행렬과 역행렬

*행렬의 곱의 결합법칙 : 순서가 같으면 뭔짓을 해도 연산 결과는 같다.
A*B    = C
(vA)*B = vC

벡터와 행렬의 곱 : 15번 연산
n = 4, i = 10000
(15 * 4) * 10000 = 600,000

n = 10, i = 10000
(15 * 10) * 10000 = 1500,000

행렬과 행렬의 곱 : 45번 연산
n = 4, i = 10000
(45 * 3) + 15 * 10000 = 150,135 

n = 10, i = 10000
(45 * 10) + 15 * 10000 = 150,405

변환을 행렬로 처리하면 효율적이다!!
행렬의 곱의 성질을 잘 이용하면 계산량을 줄일 수 있다!

*평행이동
(X, Y, Z) = (x+a, y+b, z+c)
평행이동은 3x3 행렬로 표현이 불가능하다. 왜?
지구상에서는 해결을 못하는 문제.

*동차 좌표계
이런 문제를 해결하기 위해서!!
차원을 4차원으로 늘리겠다!!!
(X, Y, Z, W)
4차원으로 늘린 후 평행이동을 수행하고 3차원으로 바꾼다.
4차원의 W가 1일때에 3차원 좌표와 동일하기 때문에 W를 나눈다.
(X, Y, Z, 1)은 (X, Y, Z)와 동차이다.

행렬도 4x4로 되어야 한다.
4열은 항상 (0, 0, 0, 1)
4행은 평행이동을 담당한다. 

* 평행이동 (변환) 행렬
* Z축 회전과 평행이동

* 좌표계 변환의 행렬 표현
결과를 알면 그 결과를 반영하는 행렬을 만들 수 있다.

*행렬의 행은 축을 나타낸다*
위치를 표현(점)	: W가 1 --> 4행이 0이 된다.
방향을 표현(벡터) 	: W가 0 --> 4행에 값이 들어온다.

# 월드 변환 행렬

CObject -> 월드 좌표계에서 객체의 위치와 방향을 나타내기 위하여
하나의 행렬을 사용

class CObject
{
	CMesh 	*m_pMesh;
	MATRIX  m_WorldMatrix;
};

* 월드 변환 행렬
  1행 Right 	Vector
  2행 Up 	Vector
  3행 Look 	Vector
  4행 Position	Vector

오브젝트의 모델좌표계 축은 월드변환시 회전을 하면 값이 바뀔수 있다.

